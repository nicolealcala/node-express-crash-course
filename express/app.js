const path = require('path');
const express = require('express');
const morgan = require('morgan');
require('dotenv').config({ path: path.join(__dirname, "..", ".env") });
const mongoose = require('mongoose');
const blogRoutes = require('../routes/blogRoutes');


const PORT = 3000;

// Express app
const app = express();

/**
 * DATABASE NOTES:
 * 
 * mongoose.connect()
 * ├── Returns a PROMISE, thus we can chain callbacks using `.then()` and `.catch()` methods.
 * └── We can pass the `app.listen()` in the .then() method as a callback to only listen 
 *     for requests when the DB connection is established.  
 * 
 */

mongoose.connect(process.env.DB_URI)
    .then(() => app.listen(PORT, () => { console.log("Listening to port", PORT) }))
    .catch(() => console.error("Failed to connect to DB"));

/**
 * CONFIGURATION NOTES:
 * 
 * app.set()
 *  ├── Used to assign a setting (configuration) name to a value on the `app` object.
 *  ├── Express recognizes certain predefined setting names that influence the application's
 *      behavior. Example: views, view engine, port, and strict routing. 
 *  ├── We can also use this to store any custom data or variables that we want to make 
 *  │   globally accessible within our application, without being limited to the predefined
 *  │   Express settings.
 *  └── To retrieve a value from the app's settings, we use the app.get()
 * 
 */
app.set('view engine', 'ejs')
app.set('views', path.join(__dirname, '..', 'views/dynamic'))

/**
 * ROUTING & MIDDLEWARE
 * 
 * app.use()
 *  ├── Used to mount middleware functions (built-in, third-party, or custom-made).
 *  ├── When called wthout a specified path/route, the callback/middleware function 
 *  │   will be executed for every incoming request regardless of the URL path or
 *  │   HTTP method. 
 *  └── When the handler function does not return a response, should explicitly call 
 *      next(), which is a callback function passed to the handler to proceed to the
 *      next middleware(s)/handler(s).
 * 
 * express.static()
 *  ├── Middleware for 'exposing' static files (stylesheets, images, etc.) to the public.
 *  └── Accepts root directory/folder that contains static files to expose.
 * 
 * response.render()
 *  ├── Used to send back dynamic HTML pages (generated by the server, thus SSR).
 *  └── A template engine (EJS, Pug, Handlebars, etc.) is required for embedding dynamic 
 *      data into the HTML document.
 */


app.use(express.static(path.join(__dirname, '..', 'public'))); //Static files

app.use(express.urlencoded({ extended: true })) // converts request body data into workable format (JavaScript Object)

app.use((req, res, next) => { // Custom logger middleware
    console.log('--------NEW REQUEST--------');
    console.log('Host: ', req.hostname);
    console.log('Path: ', req.path);
    console.log('Method: ', req.method);
    console.log('Body: ', req.body ?? "None provided");
    console.log()
    next(); // --> callback used to move on to the next middleware/handler.
});

app.use(morgan('dev')); // Third-party logger middleware

// Route handlers
app.get('/', (req, res) => {
    res.redirect('/blogs')
})

app.get('/about', (req, res) => {
    res.render('about', { title: "About Us" })
})

app.get('/about-us', (req, res) => {
    res.redirect('/about')
})

app.use('/blogs', blogRoutes); //Blog router (using Express Router)

// Catch-all request handler, should always be the last for 404 response
app.use((req, res) => {
    res.status(404).render('404', { title: "Not Found" })
})
